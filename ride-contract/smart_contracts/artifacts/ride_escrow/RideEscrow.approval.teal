#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8 32 100000
    bytecblock 0x72 "ride_counter" "total_completed" "total_rides_created" 0x151f7c75 0x70
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/ride_escrow/contract.py:38
    // self.ride_counter = UInt64(0)
    bytec_1 // "ride_counter"
    intc_1 // 0
    app_global_put
    // smart_contracts/ride_escrow/contract.py:39
    // self.total_completed = UInt64(0)
    bytec_2 // "total_completed"
    intc_1 // 0
    app_global_put
    // smart_contracts/ride_escrow/contract.py:40
    // self.total_rides_created = UInt64(0)
    bytec_3 // "total_rides_created"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/ride_escrow/contract.py:25
    // class RideEscrow(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@18
    txn OnCompletion
    !
    assert
    txn ApplicationID
    assert
    pushbytess 0x09d6c4d7 0xeca97c38 0xcba1acb0 0xc3dd3524 0x2b4036d6 0xaebdbc90 0xcc471502 0x796aa334 0x0ff4942d // method "create_ride(uint64,uint64)uint64", method "join_ride(uint64,pay)void", method "cancel_booking(uint64)void", method "complete_ride(uint64)void", method "cancel_ride(uint64)void", method "get_ride_count()uint64", method "get_total_completed()uint64", method "get_total_rides()uint64", method "get_platform_info()string"
    txna ApplicationArgs 0
    match create_ride join_ride cancel_booking complete_ride cancel_ride get_ride_count get_total_completed get_total_rides main_get_platform_info_route@14
    err

main_get_platform_info_route@14:
    // smart_contracts/ride_escrow/contract.py:311
    // @abimethod(readonly=True)
    pushbytes 0x151f7c75002d52494445202d20446563656e7472616c697a656420526964652053686172696e67206f6e20416c676f72616e64
    log
    intc_0 // 1
    return

main___algopy_default_create@18:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return


// smart_contracts.ride_escrow.contract.RideEscrow.create_ride[routing]() -> void:
create_ride:
    // smart_contracts/ride_escrow/contract.py:44
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/ride_escrow/contract.py:53
    // assert seats >= UInt64(1), "Min 1 seat"
    dup
    assert // Min 1 seat
    // smart_contracts/ride_escrow/contract.py:54
    // assert seats <= UInt64(6), "Max 6 seats"
    dup
    pushint 6
    <=
    assert // Max 6 seats
    // smart_contracts/ride_escrow/contract.py:55
    // assert price > UInt64(0), "Price must be > 0"
    dig 1
    assert // Price must be > 0
    // smart_contracts/ride_escrow/contract.py:57
    // self.ride_counter += UInt64(1)
    intc_1 // 0
    bytec_1 // "ride_counter"
    app_global_get_ex
    assert // check self.ride_counter exists
    intc_0 // 1
    +
    bytec_1 // "ride_counter"
    dig 1
    app_global_put
    // smart_contracts/ride_escrow/contract.py:60-61
    // # Build box key
    // ride_key = op.concat(b"r", op.itob(ride_id))
    itob
    bytec_0 // 0x72
    dig 1
    concat
    // smart_contracts/ride_escrow/contract.py:65
    // Txn.sender.bytes,
    txn Sender
    // smart_contracts/ride_escrow/contract.py:67
    // op.itob(price),
    uncover 4
    itob
    // smart_contracts/ride_escrow/contract.py:69
    // op.itob(seats),
    uncover 4
    itob
    // smart_contracts/ride_escrow/contract.py:70-76
    // op.concat(
    //     op.itob(UInt64(0)),   # seats_taken
    //     op.concat(
    //         op.itob(UInt64(1)),   # is_active = true
    //         op.itob(UInt64(0)),   # is_completed = false
    //     ),
    // ),
    pushbytes 0x000000000000000000000000000000010000000000000000
    // smart_contracts/ride_escrow/contract.py:68-77
    // op.concat(
    //     op.itob(seats),
    //     op.concat(
    //         op.itob(UInt64(0)),   # seats_taken
    //         op.concat(
    //             op.itob(UInt64(1)),   # is_active = true
    //             op.itob(UInt64(0)),   # is_completed = false
    //         ),
    //     ),
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:66-78
    // op.concat(
    //     op.itob(price),
    //     op.concat(
    //         op.itob(seats),
    //         op.concat(
    //             op.itob(UInt64(0)),   # seats_taken
    //             op.concat(
    //                 op.itob(UInt64(1)),   # is_active = true
    //                 op.itob(UInt64(0)),   # is_completed = false
    //             ),
    //         ),
    //     ),
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:63-79
    // # Build ride data: 72 bytes total
    // ride_data = op.concat(
    //     Txn.sender.bytes,
    //     op.concat(
    //         op.itob(price),
    //         op.concat(
    //             op.itob(seats),
    //             op.concat(
    //                 op.itob(UInt64(0)),   # seats_taken
    //                 op.concat(
    //                     op.itob(UInt64(1)),   # is_active = true
    //                     op.itob(UInt64(0)),   # is_completed = false
    //                 ),
    //             ),
    //         ),
    //     ),
    // )
    concat
    // smart_contracts/ride_escrow/contract.py:81
    // op.Box.put(ride_key, ride_data)
    box_put
    // smart_contracts/ride_escrow/contract.py:82
    // self.total_rides_created += UInt64(1)
    intc_1 // 0
    bytec_3 // "total_rides_created"
    app_global_get_ex
    assert // check self.total_rides_created exists
    intc_0 // 1
    +
    bytec_3 // "total_rides_created"
    swap
    app_global_put
    // smart_contracts/ride_escrow/contract.py:44
    // @abimethod()
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.ride_escrow.contract.RideEscrow.join_ride[routing]() -> void:
join_ride:
    // smart_contracts/ride_escrow/contract.py:86
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/ride_escrow/contract.py:92
    // ride_key = op.concat(b"r", op.itob(ride_id))
    swap
    itob
    bytec_0 // 0x72
    dig 1
    concat
    // smart_contracts/ride_escrow/contract.py:93-94
    // # op.Box.get returns (Bytes, bool) â€” value first, exists second
    // data, data_exists = op.Box.get(ride_key)
    dup
    box_get
    // smart_contracts/ride_escrow/contract.py:95
    // assert data_exists, "Ride not found"
    assert // Ride not found
    // smart_contracts/ride_escrow/contract.py:97-98
    // # Parse stored ride data
    // driver_bytes = op.extract(data, 0, 32)
    dup
    extract 0 32
    // smart_contracts/ride_escrow/contract.py:99
    // price = op.btoi(op.extract(data, 32, 8))
    dig 1
    intc_3 // 32
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:100
    // seats = op.btoi(op.extract(data, 40, 8))
    dig 2
    pushint 40
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:101
    // taken = op.btoi(op.extract(data, 48, 8))
    dig 3
    pushint 48
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:102
    // active = op.btoi(op.extract(data, 56, 8))
    uncover 4
    pushint 56
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:104-105
    // # Validations
    // assert active == UInt64(1), "Ride not active"
    intc_0 // 1
    ==
    assert // Ride not active
    // smart_contracts/ride_escrow/contract.py:106
    // assert taken < seats, "Ride is full"
    dup
    dig 2
    <
    assert // Ride is full
    // smart_contracts/ride_escrow/contract.py:107
    // assert Txn.sender.bytes != driver_bytes, "Driver can't join own ride"
    txn Sender
    dig 4
    !=
    assert // Driver can't join own ride
    // smart_contracts/ride_escrow/contract.py:108
    // assert payment.receiver == Global.current_application_address, "Pay the contract"
    dig 6
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Pay the contract
    // smart_contracts/ride_escrow/contract.py:109
    // assert payment.amount == price, "Wrong payment amount"
    uncover 6
    gtxns Amount
    dig 3
    ==
    assert // Wrong payment amount
    // smart_contracts/ride_escrow/contract.py:111-112
    // # Store passenger in a separate box
    // pass_key = op.concat(b"p", op.concat(op.itob(ride_id), op.itob(taken)))
    dup
    itob
    uncover 6
    swap
    concat
    bytec 5 // 0x70
    swap
    concat
    // smart_contracts/ride_escrow/contract.py:113
    // op.Box.put(pass_key, Txn.sender.bytes)
    txn Sender
    box_put
    // smart_contracts/ride_escrow/contract.py:115-116
    // # Update seats_taken in ride data
    // new_taken = taken + UInt64(1)
    intc_0 // 1
    +
    // smart_contracts/ride_escrow/contract.py:120
    // op.itob(price),
    uncover 2
    itob
    // smart_contracts/ride_escrow/contract.py:122
    // op.itob(seats),
    uncover 2
    itob
    // smart_contracts/ride_escrow/contract.py:124
    // op.itob(new_taken),
    uncover 2
    itob
    // smart_contracts/ride_escrow/contract.py:125-128
    // op.concat(
    //     op.itob(UInt64(1)),   # still active
    //     op.itob(UInt64(0)),   # not completed
    // ),
    pushbytes 0x00000000000000010000000000000000
    // smart_contracts/ride_escrow/contract.py:123-129
    // op.concat(
    //     op.itob(new_taken),
    //     op.concat(
    //         op.itob(UInt64(1)),   # still active
    //         op.itob(UInt64(0)),   # not completed
    //     ),
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:121-130
    // op.concat(
    //     op.itob(seats),
    //     op.concat(
    //         op.itob(new_taken),
    //         op.concat(
    //             op.itob(UInt64(1)),   # still active
    //             op.itob(UInt64(0)),   # not completed
    //         ),
    //     ),
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:119-131
    // op.concat(
    //     op.itob(price),
    //     op.concat(
    //         op.itob(seats),
    //         op.concat(
    //             op.itob(new_taken),
    //             op.concat(
    //                 op.itob(UInt64(1)),   # still active
    //                 op.itob(UInt64(0)),   # not completed
    //             ),
    //         ),
    //     ),
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:117-132
    // updated = op.concat(
    //     driver_bytes,
    //     op.concat(
    //         op.itob(price),
    //         op.concat(
    //             op.itob(seats),
    //             op.concat(
    //                 op.itob(new_taken),
    //                 op.concat(
    //                     op.itob(UInt64(1)),   # still active
    //                     op.itob(UInt64(0)),   # not completed
    //                 ),
    //             ),
    //         ),
    //     ),
    // )
    concat
    // smart_contracts/ride_escrow/contract.py:133
    // op.Box.put(ride_key, updated)
    box_put
    // smart_contracts/ride_escrow/contract.py:86
    // @abimethod()
    intc_0 // 1
    return


// smart_contracts.ride_escrow.contract.RideEscrow.cancel_booking[routing]() -> void:
cancel_booking:
    intc_1 // 0
    pushbytes ""
    // smart_contracts/ride_escrow/contract.py:135
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/ride_escrow/contract.py:141
    // ride_key = op.concat(b"r", op.itob(ride_id))
    itob
    dup
    bytec_0 // 0x72
    swap
    concat
    dup
    // smart_contracts/ride_escrow/contract.py:142
    // data, data_exists = op.Box.get(ride_key)
    box_get
    swap
    dup
    uncover 2
    // smart_contracts/ride_escrow/contract.py:143
    // assert data_exists, "Ride not found"
    assert // Ride not found
    // smart_contracts/ride_escrow/contract.py:145
    // driver = Account(op.extract(data, 0, 32))
    dup
    extract 0 32
    dup
    uncover 2
    // smart_contracts/ride_escrow/contract.py:146
    // price = op.btoi(op.extract(data, 32, 8))
    dup
    intc_3 // 32
    extract_uint64
    cover 2
    // smart_contracts/ride_escrow/contract.py:147
    // taken = op.btoi(op.extract(data, 48, 8))
    dup
    pushint 48
    extract_uint64
    cover 2
    pushint 56
    // smart_contracts/ride_escrow/contract.py:148
    // active = op.btoi(op.extract(data, 56, 8))
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:150
    // assert active == UInt64(1), "Ride not active"
    intc_0 // 1
    ==
    assert // Ride not active
    // smart_contracts/ride_escrow/contract.py:151
    // assert Txn.sender != driver, "Driver cannot cancel booking"
    txn Sender
    !=
    assert // Driver cannot cancel booking
    // smart_contracts/ride_escrow/contract.py:153-154
    // # Find rider's index
    // i = UInt64(0)
    intc_1 // 0
    // smart_contracts/ride_escrow/contract.py:155
    // found_index = UInt64(999)
    pushint 999

cancel_booking_while_top@2:
    // smart_contracts/ride_escrow/contract.py:156
    // while i < taken:
    dig 1
    dig 3
    <
    bz cancel_booking_after_while@7
    // smart_contracts/ride_escrow/contract.py:157
    // pass_key = op.concat(b"p", op.concat(op.itob(ride_id), op.itob(i)))
    dig 1
    itob
    dig 8
    swap
    concat
    bytec 5 // 0x70
    swap
    concat
    // smart_contracts/ride_escrow/contract.py:158
    // p_data, p_exists = op.Box.get(pass_key)
    box_get
    swap
    bury 11
    // smart_contracts/ride_escrow/contract.py:159
    // if p_exists and Account(p_data) == Txn.sender:
    bz cancel_booking_after_if_else@6
    dig 9
    dup
    len
    intc_3 // 32
    ==
    assert // Address length is 32 bytes
    txn Sender
    ==
    bz cancel_booking_after_if_else@6
    dig 1
    bury 1

cancel_booking_after_while@7:
    // smart_contracts/ride_escrow/contract.py:164
    // assert found_index != UInt64(999), "Not a passenger of this ride"
    dup
    pushint 999
    !=
    assert // Not a passenger of this ride
    // smart_contracts/ride_escrow/contract.py:168
    // refund_amount = price - penalty if price > penalty else UInt64(0)
    dig 3
    // smart_contracts/ride_escrow/contract.py:166-167
    // # Calculate refund: price - 0.1 ALGO penalty
    // penalty = UInt64(100_000)  # 0.1 ALGO
    intc 4 // 100000
    // smart_contracts/ride_escrow/contract.py:168
    // refund_amount = price - penalty if price > penalty else UInt64(0)
    >
    bz cancel_booking_ternary_false@9
    dig 3
    // smart_contracts/ride_escrow/contract.py:166-167
    // # Calculate refund: price - 0.1 ALGO penalty
    // penalty = UInt64(100_000)  # 0.1 ALGO
    intc 4 // 100000
    // smart_contracts/ride_escrow/contract.py:168
    // refund_amount = price - penalty if price > penalty else UInt64(0)
    -
    bury 9

cancel_booking_ternary_merge@10:
    // smart_contracts/ride_escrow/contract.py:170-171
    // # Refund rider (minus penalty)
    // if refund_amount > UInt64(0):
    dig 8
    bz cancel_booking_after_if_else@13
    // smart_contracts/ride_escrow/contract.py:172-176
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=refund_amount,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/ride_escrow/contract.py:173
    // receiver=Txn.sender,
    txn Sender
    dig 9
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/ride_escrow/contract.py:172
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/ride_escrow/contract.py:175
    // fee=UInt64(0),
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/ride_escrow/contract.py:172-176
    // itxn.Payment(
    //     receiver=Txn.sender,
    //     amount=refund_amount,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit

cancel_booking_after_if_else@13:
    // smart_contracts/ride_escrow/contract.py:180-184
    // itxn.Payment(
    //     receiver=driver,
    //     amount=penalty,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    // smart_contracts/ride_escrow/contract.py:166-167
    // # Calculate refund: price - 0.1 ALGO penalty
    // penalty = UInt64(100_000)  # 0.1 ALGO
    intc 4 // 100000
    itxn_field Amount
    dig 4
    itxn_field Receiver
    // smart_contracts/ride_escrow/contract.py:180
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/ride_escrow/contract.py:183
    // fee=UInt64(0),
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/ride_escrow/contract.py:180-184
    // itxn.Payment(
    //     receiver=driver,
    //     amount=penalty,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit
    // smart_contracts/ride_escrow/contract.py:186-187
    // # Remove passenger from box
    // pass_key = op.concat(b"p", op.concat(op.itob(ride_id), op.itob(found_index)))
    dup
    itob
    dig 8
    swap
    concat
    bytec 5 // 0x70
    swap
    concat
    // smart_contracts/ride_escrow/contract.py:188
    // op.Box.delete(pass_key)
    box_del
    pop
    // smart_contracts/ride_escrow/contract.py:190-191
    // # Decrease seats_taken
    // new_taken = taken - UInt64(1) if taken > UInt64(0) else UInt64(0)
    dig 2
    bz cancel_booking_ternary_false@18
    dig 2
    intc_0 // 1
    -

cancel_booking_ternary_merge@19:
    // smart_contracts/ride_escrow/contract.py:193
    // op.extract(data, 0, 48),
    dig 6
    dup
    extract 0 48
    // smart_contracts/ride_escrow/contract.py:195
    // op.itob(new_taken),
    uncover 2
    itob
    // smart_contracts/ride_escrow/contract.py:196
    // op.extract(data, 56, 16),
    uncover 2
    extract 56 16
    // smart_contracts/ride_escrow/contract.py:194-197
    // op.concat(
    //     op.itob(new_taken),
    //     op.extract(data, 56, 16),
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:192-198
    // updated = op.concat(
    //     op.extract(data, 0, 48),
    //     op.concat(
    //         op.itob(new_taken),
    //         op.extract(data, 56, 16),
    //     ),
    // )
    concat
    // smart_contracts/ride_escrow/contract.py:199
    // op.Box.put(ride_key, updated)
    dig 7
    swap
    box_put
    // smart_contracts/ride_escrow/contract.py:135
    // @abimethod()
    intc_0 // 1
    return

cancel_booking_ternary_false@18:
    // smart_contracts/ride_escrow/contract.py:190-191
    // # Decrease seats_taken
    // new_taken = taken - UInt64(1) if taken > UInt64(0) else UInt64(0)
    intc_1 // 0
    b cancel_booking_ternary_merge@19

cancel_booking_ternary_false@9:
    // smart_contracts/ride_escrow/contract.py:168
    // refund_amount = price - penalty if price > penalty else UInt64(0)
    intc_1 // 0
    bury 9
    b cancel_booking_ternary_merge@10

cancel_booking_after_if_else@6:
    // smart_contracts/ride_escrow/contract.py:162
    // i += UInt64(1)
    dig 1
    intc_0 // 1
    +
    bury 2
    b cancel_booking_while_top@2


// smart_contracts.ride_escrow.contract.RideEscrow.complete_ride[routing]() -> void:
complete_ride:
    // smart_contracts/ride_escrow/contract.py:201
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/ride_escrow/contract.py:207
    // ride_key = op.concat(b"r", op.itob(ride_id))
    itob
    bytec_0 // 0x72
    swap
    concat
    // smart_contracts/ride_escrow/contract.py:208
    // data, data_exists = op.Box.get(ride_key)
    dup
    box_get
    // smart_contracts/ride_escrow/contract.py:209
    // assert data_exists, "Ride not found"
    assert // Ride not found
    // smart_contracts/ride_escrow/contract.py:211
    // driver = Account(op.extract(data, 0, 32))
    dup
    extract 0 32
    // smart_contracts/ride_escrow/contract.py:212
    // price = op.btoi(op.extract(data, 32, 8))
    dig 1
    intc_3 // 32
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:213
    // taken = op.btoi(op.extract(data, 48, 8))
    dig 2
    pushint 48
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:214
    // active = op.btoi(op.extract(data, 56, 8))
    dig 3
    pushint 56
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:215
    // completed = op.btoi(op.extract(data, 64, 8))
    dig 4
    pushint 64
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:217
    // assert Txn.sender == driver, "Only driver can complete"
    txn Sender
    dig 5
    ==
    assert // Only driver can complete
    // smart_contracts/ride_escrow/contract.py:218
    // assert active == UInt64(1), "Not active"
    swap
    intc_0 // 1
    ==
    assert // Not active
    // smart_contracts/ride_escrow/contract.py:219
    // assert completed == UInt64(0), "Already completed"
    !
    assert // Already completed
    // smart_contracts/ride_escrow/contract.py:220
    // assert taken > UInt64(0), "No passengers"
    dup
    assert // No passengers
    // smart_contracts/ride_escrow/contract.py:222-223
    // # Pay the driver: price * number of passengers
    // total = price * taken
    swap
    dig 1
    *
    // smart_contracts/ride_escrow/contract.py:224-228
    // itxn.Payment(
    //     receiver=driver,
    //     amount=total,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    itxn_field Amount
    swap
    itxn_field Receiver
    // smart_contracts/ride_escrow/contract.py:224
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/ride_escrow/contract.py:227
    // fee=UInt64(0),
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/ride_escrow/contract.py:224-228
    // itxn.Payment(
    //     receiver=driver,
    //     amount=total,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit
    // smart_contracts/ride_escrow/contract.py:232
    // op.extract(data, 0, 48),   # driver + price + seats unchanged
    swap
    extract 0 48
    // smart_contracts/ride_escrow/contract.py:234
    // op.itob(taken),            # seats_taken unchanged
    swap
    itob
    // smart_contracts/ride_escrow/contract.py:235-238
    // op.concat(
    //     op.itob(UInt64(0)),    # active = false
    //     op.itob(UInt64(1)),    # completed = true
    // ),
    pushbytes 0x00000000000000000000000000000001
    // smart_contracts/ride_escrow/contract.py:233-239
    // op.concat(
    //     op.itob(taken),            # seats_taken unchanged
    //     op.concat(
    //         op.itob(UInt64(0)),    # active = false
    //         op.itob(UInt64(1)),    # completed = true
    //     ),
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:230-240
    // # Update ride: active=false, completed=true
    // updated = op.concat(
    //     op.extract(data, 0, 48),   # driver + price + seats unchanged
    //     op.concat(
    //         op.itob(taken),            # seats_taken unchanged
    //         op.concat(
    //             op.itob(UInt64(0)),    # active = false
    //             op.itob(UInt64(1)),    # completed = true
    //         ),
    //     ),
    // )
    concat
    // smart_contracts/ride_escrow/contract.py:241
    // op.Box.put(ride_key, updated)
    box_put
    // smart_contracts/ride_escrow/contract.py:242
    // self.total_completed += UInt64(1)
    intc_1 // 0
    bytec_2 // "total_completed"
    app_global_get_ex
    assert // check self.total_completed exists
    intc_0 // 1
    +
    bytec_2 // "total_completed"
    swap
    app_global_put
    // smart_contracts/ride_escrow/contract.py:201
    // @abimethod()
    intc_0 // 1
    return


// smart_contracts.ride_escrow.contract.RideEscrow.cancel_ride[routing]() -> void:
cancel_ride:
    intc_1 // 0
    dup
    // smart_contracts/ride_escrow/contract.py:244
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/ride_escrow/contract.py:250
    // ride_key = op.concat(b"r", op.itob(ride_id))
    itob
    dup
    bytec_0 // 0x72
    swap
    concat
    dup
    // smart_contracts/ride_escrow/contract.py:251
    // data, data_exists = op.Box.get(ride_key)
    box_get
    swap
    dup
    uncover 2
    // smart_contracts/ride_escrow/contract.py:252
    // assert data_exists, "Ride not found"
    assert // Ride not found
    // smart_contracts/ride_escrow/contract.py:254
    // driver = Account(op.extract(data, 0, 32))
    dup
    extract 0 32
    // smart_contracts/ride_escrow/contract.py:255
    // price = op.btoi(op.extract(data, 32, 8))
    dig 1
    intc_3 // 32
    extract_uint64
    cover 2
    // smart_contracts/ride_escrow/contract.py:256
    // taken = op.btoi(op.extract(data, 48, 8))
    dig 1
    pushint 48
    extract_uint64
    cover 2
    // smart_contracts/ride_escrow/contract.py:257
    // active = op.btoi(op.extract(data, 56, 8))
    swap
    pushint 56
    extract_uint64
    // smart_contracts/ride_escrow/contract.py:259
    // assert Txn.sender == driver, "Only driver can cancel"
    txn Sender
    uncover 2
    ==
    assert // Only driver can cancel
    // smart_contracts/ride_escrow/contract.py:260
    // assert active == UInt64(1), "Not active"
    intc_0 // 1
    ==
    assert // Not active
    // smart_contracts/ride_escrow/contract.py:264-265
    // # Refund each passenger + penalty compensation
    // i = UInt64(0)
    intc_1 // 0

cancel_ride_while_top@2:
    // smart_contracts/ride_escrow/contract.py:266
    // while i < taken:
    dup
    dig 2
    <
    bz cancel_ride_after_while@7
    // smart_contracts/ride_escrow/contract.py:267
    // pass_key = op.concat(b"p", op.concat(op.itob(ride_id), op.itob(i)))
    dup
    itob
    dig 6
    swap
    concat
    bytec 5 // 0x70
    swap
    concat
    dup
    bury 8
    // smart_contracts/ride_escrow/contract.py:268
    // p_data, p_exists = op.Box.get(pass_key)
    box_get
    swap
    bury 9
    // smart_contracts/ride_escrow/contract.py:269
    // if p_exists:
    bz cancel_ride_after_if_else@6
    // smart_contracts/ride_escrow/contract.py:270
    // rider = Account(p_data)
    dig 7
    dup
    len
    intc_3 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/ride_escrow/contract.py:271-272
    // # Refund original price + 0.1 ALGO compensation
    // refund_with_penalty = price + penalty_per_rider
    dig 3
    // smart_contracts/ride_escrow/contract.py:262
    // penalty_per_rider = UInt64(100_000)  # 0.1 ALGO per rider
    intc 4 // 100000
    // smart_contracts/ride_escrow/contract.py:271-272
    // # Refund original price + 0.1 ALGO compensation
    // refund_with_penalty = price + penalty_per_rider
    +
    // smart_contracts/ride_escrow/contract.py:273-277
    // itxn.Payment(
    //     receiver=rider,
    //     amount=refund_with_penalty,
    //     fee=UInt64(0),
    // ).submit()
    itxn_begin
    itxn_field Amount
    itxn_field Receiver
    // smart_contracts/ride_escrow/contract.py:273
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/ride_escrow/contract.py:276
    // fee=UInt64(0),
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/ride_escrow/contract.py:273-277
    // itxn.Payment(
    //     receiver=rider,
    //     amount=refund_with_penalty,
    //     fee=UInt64(0),
    // ).submit()
    itxn_submit
    // smart_contracts/ride_escrow/contract.py:278
    // op.Box.delete(pass_key)
    dig 6
    box_del
    pop

cancel_ride_after_if_else@6:
    // smart_contracts/ride_escrow/contract.py:279
    // i += UInt64(1)
    dup
    intc_0 // 1
    +
    bury 1
    b cancel_ride_while_top@2

cancel_ride_after_while@7:
    // smart_contracts/ride_escrow/contract.py:283
    // op.extract(data, 0, 48),
    dig 3
    dup
    extract 0 48
    // smart_contracts/ride_escrow/contract.py:285
    // op.itob(taken),
    dig 3
    itob
    // smart_contracts/ride_escrow/contract.py:287
    // op.itob(UInt64(0)),    # active = false
    intc_1 // 0
    itob
    // smart_contracts/ride_escrow/contract.py:288
    // op.extract(data, 64, 8),  # completed stays same
    uncover 3
    extract 64 8
    // smart_contracts/ride_escrow/contract.py:286-289
    // op.concat(
    //     op.itob(UInt64(0)),    # active = false
    //     op.extract(data, 64, 8),  # completed stays same
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:284-290
    // op.concat(
    //     op.itob(taken),
    //     op.concat(
    //         op.itob(UInt64(0)),    # active = false
    //         op.extract(data, 64, 8),  # completed stays same
    //     ),
    // ),
    concat
    // smart_contracts/ride_escrow/contract.py:281-291
    // # Update ride: active=false
    // updated = op.concat(
    //     op.extract(data, 0, 48),
    //     op.concat(
    //         op.itob(taken),
    //         op.concat(
    //             op.itob(UInt64(0)),    # active = false
    //             op.extract(data, 64, 8),  # completed stays same
    //         ),
    //     ),
    // )
    concat
    // smart_contracts/ride_escrow/contract.py:292
    // op.Box.put(ride_key, updated)
    dig 5
    swap
    box_put
    // smart_contracts/ride_escrow/contract.py:244
    // @abimethod()
    intc_0 // 1
    return


// smart_contracts.ride_escrow.contract.RideEscrow.get_ride_count[routing]() -> void:
get_ride_count:
    // smart_contracts/ride_escrow/contract.py:299
    // return self.ride_counter
    intc_1 // 0
    bytec_1 // "ride_counter"
    app_global_get_ex
    assert // check self.ride_counter exists
    // smart_contracts/ride_escrow/contract.py:296
    // @abimethod(readonly=True)
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.ride_escrow.contract.RideEscrow.get_total_completed[routing]() -> void:
get_total_completed:
    // smart_contracts/ride_escrow/contract.py:304
    // return self.total_completed
    intc_1 // 0
    bytec_2 // "total_completed"
    app_global_get_ex
    assert // check self.total_completed exists
    // smart_contracts/ride_escrow/contract.py:301
    // @abimethod(readonly=True)
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.ride_escrow.contract.RideEscrow.get_total_rides[routing]() -> void:
get_total_rides:
    // smart_contracts/ride_escrow/contract.py:309
    // return self.total_rides_created
    intc_1 // 0
    bytec_3 // "total_rides_created"
    app_global_get_ex
    assert // check self.total_rides_created exists
    // smart_contracts/ride_escrow/contract.py:306
    // @abimethod(readonly=True)
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
